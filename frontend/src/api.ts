/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { customAxiosInstance } from "./api-client";
export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Response model for a poem
 */
export interface PoemResponse {
  poem_content: string;
}

export interface PoemV1CreateRequest {
  name: string;
  email: string;
  message: string;
}

export interface PoemV2CreateRequest {
  name: string;
  email: string;
  message: string;
}

export interface PoemV3CreateRequest {
  name: string;
  email: string;
  message: string;
}

export type PoemV4CreateRequestInputImageUrl = string | null;

export type PoemV4CreateRequestReplacementTypeCounts =
  ReplacementTypeCounts | null;

export type PoemV4CreateRequestNumRelatedImages = number | null;

export type PoemV4CreateRequestModel = string | null;

export type PoemV4CreateRequestPassImageToModel = boolean | null;

/**
 * Request model for generating a multimodal variation
 */
export interface PoemV4CreateRequest {
  inputImageUrl?: PoemV4CreateRequestInputImageUrl;
  replacementTypeCounts?: PoemV4CreateRequestReplacementTypeCounts;
  numRelatedImages?: PoemV4CreateRequestNumRelatedImages;
  model?: PoemV4CreateRequestModel;
  passImageToModel?: PoemV4CreateRequestPassImageToModel;
}

export type ReplacementTypeCountsMeansLike = number | null;

export type ReplacementTypeCountsTriggeredBy = number | null;

export type ReplacementTypeCountsAnagram = number | null;

export type ReplacementTypeCountsSpelledLike = number | null;

export type ReplacementTypeCountsConsonantMatch = number | null;

export type ReplacementTypeCountsHomophone = number | null;

/**
 * Counts for each type of replacement to apply
 */
export interface ReplacementTypeCounts {
  means_like?: ReplacementTypeCountsMeansLike;
  triggered_by?: ReplacementTypeCountsTriggeredBy;
  anagram?: ReplacementTypeCountsAnagram;
  spelled_like?: ReplacementTypeCountsSpelledLike;
  consonant_match?: ReplacementTypeCountsConsonantMatch;
  homophone?: ReplacementTypeCountsHomophone;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * @summary Api Info
 */
export const apiInfoInfoGet = (signal?: AbortSignal) => {
  return customAxiosInstance<unknown>({ url: `/info`, method: "GET", signal });
};

export const getApiInfoInfoGetQueryKey = () => {
  return [`/info`] as const;
};

export const getApiInfoInfoGetQueryOptions = <
  TData = Awaited<ReturnType<typeof apiInfoInfoGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof apiInfoInfoGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiInfoInfoGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof apiInfoInfoGet>>> = ({
    signal,
  }) => apiInfoInfoGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof apiInfoInfoGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiInfoInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiInfoInfoGet>>
>;
export type ApiInfoInfoGetQueryError = unknown;

export function useApiInfoInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoInfoGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiInfoInfoGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoInfoGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoInfoGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiInfoInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiInfoInfoGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiInfoInfoGet>>,
          TError,
          Awaited<ReturnType<typeof apiInfoInfoGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiInfoInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiInfoInfoGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Api Info
 */

export function useApiInfoInfoGet<
  TData = Awaited<ReturnType<typeof apiInfoInfoGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiInfoInfoGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getApiInfoInfoGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Basic health check - always returns healthy if API is running
 * @summary Health Check
 */
export const healthCheckHealthGet = (signal?: AbortSignal) => {
  return customAxiosInstance<unknown>({
    url: `/health`,
    method: "GET",
    signal,
  });
};

export const getHealthCheckHealthGetQueryKey = () => {
  return [`/health`] as const;
};

export const getHealthCheckHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof healthCheckHealthGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof healthCheckHealthGet>>
  > = ({ signal }) => healthCheckHealthGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetQueryError = unknown;

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthCheckHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthCheckHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Detailed health check including external dependencies
 * @summary Detailed Health Check
 */
export const detailedHealthCheckHealthDetailedGet = (signal?: AbortSignal) => {
  return customAxiosInstance<unknown>({
    url: `/health/detailed`,
    method: "GET",
    signal,
  });
};

export const getDetailedHealthCheckHealthDetailedGetQueryKey = () => {
  return [`/health/detailed`] as const;
};

export const getDetailedHealthCheckHealthDetailedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDetailedHealthCheckHealthDetailedGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>
  > = ({ signal }) => detailedHealthCheckHealthDetailedGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DetailedHealthCheckHealthDetailedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>
>;
export type DetailedHealthCheckHealthDetailedGetQueryError = unknown;

export function useDetailedHealthCheckHealthDetailedGet<
  TData = Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
          TError,
          Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDetailedHealthCheckHealthDetailedGet<
  TData = Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
          TError,
          Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDetailedHealthCheckHealthDetailedGet<
  TData = Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Detailed Health Check
 */

export function useDetailedHealthCheckHealthDetailedGet<
  TData = Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof detailedHealthCheckHealthDetailedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getDetailedHealthCheckHealthDetailedGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Generatepoemv1
 */
export const generatePoemV1GeneratePoemV1Post = (
  poemV1CreateRequest: PoemV1CreateRequest,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<unknown>({
    url: `/generate-poem-v1`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: poemV1CreateRequest,
    signal,
  });
};

export const getGeneratePoemV1GeneratePoemV1PostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>,
    TError,
    { data: PoemV1CreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>,
  TError,
  { data: PoemV1CreateRequest },
  TContext
> => {
  const mutationKey = ["generatePoemV1GeneratePoemV1Post"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>,
    { data: PoemV1CreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePoemV1GeneratePoemV1Post(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePoemV1GeneratePoemV1PostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>
>;
export type GeneratePoemV1GeneratePoemV1PostMutationBody = PoemV1CreateRequest;
export type GeneratePoemV1GeneratePoemV1PostMutationError = HTTPValidationError;

/**
 * @summary Generatepoemv1
 */
export const useGeneratePoemV1GeneratePoemV1Post = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>,
      TError,
      { data: PoemV1CreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof generatePoemV1GeneratePoemV1Post>>,
  TError,
  { data: PoemV1CreateRequest },
  TContext
> => {
  const mutationOptions =
    getGeneratePoemV1GeneratePoemV1PostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generatepoemv2
 */
export const generatePoemV2GeneratePoemV2Post = (
  poemV2CreateRequest: PoemV2CreateRequest,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<unknown>({
    url: `/generate-poem-v2`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: poemV2CreateRequest,
    signal,
  });
};

export const getGeneratePoemV2GeneratePoemV2PostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>,
    TError,
    { data: PoemV2CreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>,
  TError,
  { data: PoemV2CreateRequest },
  TContext
> => {
  const mutationKey = ["generatePoemV2GeneratePoemV2Post"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>,
    { data: PoemV2CreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePoemV2GeneratePoemV2Post(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePoemV2GeneratePoemV2PostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>
>;
export type GeneratePoemV2GeneratePoemV2PostMutationBody = PoemV2CreateRequest;
export type GeneratePoemV2GeneratePoemV2PostMutationError = HTTPValidationError;

/**
 * @summary Generatepoemv2
 */
export const useGeneratePoemV2GeneratePoemV2Post = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>,
      TError,
      { data: PoemV2CreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof generatePoemV2GeneratePoemV2Post>>,
  TError,
  { data: PoemV2CreateRequest },
  TContext
> => {
  const mutationOptions =
    getGeneratePoemV2GeneratePoemV2PostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generatepoemv3
 */
export const generatePoemV3GeneratePoemV3Post = (
  poemV3CreateRequest: PoemV3CreateRequest,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<unknown>({
    url: `/generate-poem-v3`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: poemV3CreateRequest,
    signal,
  });
};

export const getGeneratePoemV3GeneratePoemV3PostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>,
    TError,
    { data: PoemV3CreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>,
  TError,
  { data: PoemV3CreateRequest },
  TContext
> => {
  const mutationKey = ["generatePoemV3GeneratePoemV3Post"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>,
    { data: PoemV3CreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePoemV3GeneratePoemV3Post(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePoemV3GeneratePoemV3PostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>
>;
export type GeneratePoemV3GeneratePoemV3PostMutationBody = PoemV3CreateRequest;
export type GeneratePoemV3GeneratePoemV3PostMutationError = HTTPValidationError;

/**
 * @summary Generatepoemv3
 */
export const useGeneratePoemV3GeneratePoemV3Post = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>,
      TError,
      { data: PoemV3CreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof generatePoemV3GeneratePoemV3Post>>,
  TError,
  { data: PoemV3CreateRequest },
  TContext
> => {
  const mutationOptions =
    getGeneratePoemV3GeneratePoemV3PostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Generatepoemv4
 */
export const generatePoemV4GeneratePoemV4Post = (
  poemV4CreateRequest: PoemV4CreateRequest,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<PoemResponse>({
    url: `/generate-poem-v4`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: poemV4CreateRequest,
    signal,
  });
};

export const getGeneratePoemV4GeneratePoemV4PostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>,
    TError,
    { data: PoemV4CreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>,
  TError,
  { data: PoemV4CreateRequest },
  TContext
> => {
  const mutationKey = ["generatePoemV4GeneratePoemV4Post"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>,
    { data: PoemV4CreateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generatePoemV4GeneratePoemV4Post(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GeneratePoemV4GeneratePoemV4PostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>
>;
export type GeneratePoemV4GeneratePoemV4PostMutationBody = PoemV4CreateRequest;
export type GeneratePoemV4GeneratePoemV4PostMutationError = HTTPValidationError;

/**
 * @summary Generatepoemv4
 */
export const useGeneratePoemV4GeneratePoemV4Post = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>,
      TError,
      { data: PoemV4CreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof generatePoemV4GeneratePoemV4Post>>,
  TError,
  { data: PoemV4CreateRequest },
  TContext
> => {
  const mutationOptions =
    getGeneratePoemV4GeneratePoemV4PostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
